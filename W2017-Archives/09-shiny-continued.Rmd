---
title:  "Shiny and Tidy Data Continued"
type:   content
---

# Stuff that was confusing

Here are a few topics that might help to smooth out some points of confusion from last class.

```{r}
library(shiny)
library(dplyr)
library(ggplot2)

library(nycflights13)
```

## R Markdown vs R Scripts

So far the two ways I've shown you how to interact with R are via the console and in R Markdown documents.  One point of confusion was the the code examples on the [shiny website](https://shiny.rstudio.com/) assume that you are using the third:  R scripts.

R scripts are just plain text files that contain R code.  When you run one, it's equivalent to typing all of the code it contains into the console by hand.  Scripts are particularly useful when you need to develop a library of your own functions to use on a big project.  Unlike R Markdown documents, though, they run in the global environment (by default) and can only contain non-code text in `#comment` blocks.  Those two features make R Markdown documents a better fit for reproducible research workflows.

In early versions of shiny, the way to create a shiny app was to make a folder that contained two files `ui.R` and `server.R`.

The `ui.R` script describes where the widgets and output go:

```{r eval=FALSE}
# from shiny website
fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs", "Number of observations:", min = 10, max = 500, value = 100)
    ),
    mainPanel(plotOutput("distPlot"))
  )
)
```

The `server.R` script uses `input$widget_id`'s in R code to produce output:

```{r eval=FALSE}
# from shiny website
function(input, output) {
  output$distPlot <- renderPlot({
    hist(rnorm(input$obs), col = 'darkgray', border = 'white')
  })
}
```

So that's the old way to use shiny.  It's more orderly and flexibly than using shiny embedded in an R Markdown document, and it's the approach you'll use to make your web apps.  But shiny now supports describing your app [in lots of ways](https://shiny.rstudio.com/articles/app-formats.html), including now embedded in R Markdown.

Here's a code chunk that you could put in an R Markdown document that would be equivalent to the app above:

```{r eval=FALSE}
# Widget "ui"
sliderInput("obs", "Number of observations:", min = 10, max = 500, value = 100)

# Output "server"
renderPlot({
    hist(rnorm(input$obs), col = 'darkgray', border = 'white')
})
```

There's a lot less code because R Markdown is making decisions for us.  For example, we don't need any of the layout code found in `ui.R` above because R Markdown already knows where everything is going to go: at the current location in the document.

So ignore all of the extra stuff in the Shiny documentation whether you're browsing the Shiny website or R help page:

* Widget functions are named `xxxInput(...)` (`selectInput`, `sliderInput`, etc.)
* Output functions are named `renderXXX()` (`renderPlot`, `renderDataTable`, etc.)

## Keeping annotation columns with `summary`

One very common source of bugs last class came from folks trying to use columns on `flights` that got dropped at the `summarize` step of their pipes.

For example, this won't work:

```{r eval=FALSE}
flights %>%
  group_by(origin) %>%
  summarize(n         = n(),
            ave_delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(n, ave_delay, color = carrier)) + geom_point()
```

Let's remind ourselves why that is.  Here's what we're piping into `ggplot`:

```{r}
flights %>%
  group_by(origin) %>%
  summarize(n         = n(),
            ave_delay = mean(dep_delay, na.rm = TRUE))
```

The problem of course is that we grouped by origin alone, averaging all carriers for each origin.  We wanted to group by both origin and carrier:

```{r}
flights %>%
  group_by(origin, carrier) %>%
  summarize(n         = n(),
            ave_delay = mean(dep_delay, na.rm = TRUE))
```

## Kate's question:  post-summary filtering

The question was:  how can I make a plot that only shows airlines with more than say 1000 flights at an airport?

The answer I came up with used the bad-old-way of doing things; here's the easy way:

```{r}
flights %>%
  group_by(origin, carrier) %>%
  summarize(n         = n(),
            ave_delay = mean(dep_delay, na.rm = TRUE)) %>%
  filter(n > 1000) %>%
  ggplot(aes(n, ave_delay, color = carrier)) + geom_point()
```

You can put `filters` in the pipe in as many places you want, so you can filter after the summary.

## John's question:  using input$'s as variable names

The question was: how can I make a widget and use it's value in `dplyr` calls or `ggplot` calls.  Well, he only asked the former, but I'll answer both.

**Warning:** this question and it's answer are more advanced.  If it confuses you, it's fine to ignore it and just tell yourself "you can't."

Let's say that for the plot above we want to let the user choose whether we group by origin airport or destination airport.

This won't work:

```{r eval=FALSE}
selectInput("group", label = "Group by:", choices = c("origin", "dest"))

renderPlot({
  flights %>%
  group_by(input$group, carrier) %>%
  summarize(n         = n(),
            ave_delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(n, ave_delay, color = carrier)) + geom_point()
})
```

The catch is that this line:

```{r eval=FALSE}
group_by(flights, input$group, carrier)
```

Is equivalent to this:

```{r}
group_by(flights, "origin", carrier)
```

Not this:

```{r}
group_by(flights, origin, carrier)
```

The problem is that `dplyr`, as well as `ggplot`, are using [non-standard evaluation voodoo](http://adv-r.had.co.nz/Computing-on-the-language.html) in the interest of allowing you to write concise code.  In a line like `group_by(origin, carrier)`, dplyr is taking the named variables you give it and using those names to match to variables on the table.

Fortunately, all of the magical `dplyr` functions have non-magical counterparts; they have the same name and end in an underscore `_`.  For example:

```{r}
group_by_(flights, "origin", "carrier")
```

Or:

```{r eval=FALSE}
group_by_(flights, input$group, ~carrier)
```

The `~` is a short hand in this context for "treat this next thing in the magical way again" (with more detail:  it's the formula operator that's being used to `quote` what comes after it).

For fuller documentation see:

```{r eval=FALSE}
vignette("nse")
```

In `ggplot` calls, there is a similar, but different, approach to turning off the magic:  use `aes_string()` instead of `aes()` to define your aesthetic mappings.



