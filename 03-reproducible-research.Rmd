---
title:  "Plotting and Reproducible Research"
type:   content
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.height = 5)
```

# Reproducible Research

##

Today you're going to learn how to make this:

```{r warning=FALSE}
library(ggplot2)
ggplot(diamonds, aes(depth, fill = cut)) + geom_density(alpha = 0.2) + xlim(55, 70)
```

It's only going to take one line of code, but there are a few things we need to cover to understand it!  Along the way we're also going to examine the different ways that you can interact with R to do data analysis, the advantages and disadvantages of each, and the **correct** approach for producing figures you plan to share/publish/base important decisions on.

# RStudio Projects

RStudio has a really nice feature for managing different data analysis projects, called projects.  A project is really just a folder with a special file to flag it as the location of a project.  You should create a new project for EVERY data analysis project you're working on; trust me.  Each project has it's own global environment, command history, etc.

To create a new project just use `File -> New Project`.  Create a new bio185 project for your work in this class.

# Hacking at the console

As you've seen, the *ad hoc* approach to interacting with R is to type commands in the console and interactively see the results as you go.  The command history feature in R makes this a bit safer than *ad hoc* data manipulation in other software (Excel, I'm looking at you) but today we'll see high level tools that will offer you much more reassurance that your data analysis results are solid.

## Packages

For now, let's hack at the console.  The first thing we need to understand on our way to making that pretty plot above is R `packages`.  Packages are kind of like 'apps' and the R community maintains a package repository called [CRAN](https://cran.r-project.org/) which is akin to an App Store (but much better, because it's [free and open](https://en.wikipedia.org/wiki/Open_platform)!).

##

To install a new package named `ggplot2` you'd run:

```{r eval=FALSE}
# note quotes
install.packages("ggplot2")
```

But you won't have to install any of the packages needed for excercises and assignments in this course because I've already done that for you.  Once a package is installed, you can load it into your current environment using `library`:

##

```{r}
# note quotes not needed; magic!
library(ggplot2)
```

##

Packages come with (possibly) three things:

* New functions that you can run
* Documentation for each function and sometimes higher level tutorials called 'vignettes' and 'demos'
* Data sets; usually the data needed to run examples

##

Let's open the main help page for `ggplot2`:

```{r eval=FALSE}
?ggplot2
```

If you click on the `index` link you'll see all of the functions that `ggplot2` comes with.  It's a lot; as packages go this is a big one.  It's become the community favorite for making publication quality plots.  The [ggplot2](http://ggplot2.tidyverse.org/) website has tons of great examples for any type of plot you could imagine wanting to make (well, almost any).

## Tables: data.frame's

##

One of the datasets that `ggplot2` comes with is `diamonds`.  Get a preview:

```{r eval=FALSE}
diamonds
```

```{r echo=FALSE}
head(diamonds)
```

The `diamonds` variable holds a new type of data we haven't seen before: this is a `data.frame` (well, technically it's a [tibble](https://github.com/tidyverse/tibble) but we're going to ignore that distinction for now).  This is the data structure in R that you'll nearly always use to represent a real dataset: it's two dimensional, rows represent observations, and each column represents a variable.

##

You can see how many observations a dataset has with `nrow`:

```{r}
nrow(diamonds)
```

That's a few!

##

Each column on a `data.frame` is just a vector of values.  To get the vector of data in a column you can use the short hand `$` syntax:

```{r eval=FALSE}
diamonds$cut
```

```{r echo=FALSE}
head(diamonds$cut)
```

##

You can also use the longer form `[[..]]` sytnax:

```{r eval=FALSE}
diamonds[['cut']]
diamonds[['cut']] == diamonds$cut
```

##

Note the use of quotes with `[[..]]` but not with `$`.  See what happens if you use single `[...]` on a `data.frame` column:

```{r eval=FALSE}
diamonds['cut']
```

```{r echo=FALSE}
head(diamonds['cut'])
```

What did you get?  What's the difference between double and single brackets?

##

RStudio also has a very nice interface for inspecting a `data.frame` with the `View` function (note caps):

```{r eval=FALSE}
View(diamonds)
```

## Factors

Take a look at the different columns in this data set.  There are several numeric variables which we've seen before.  But there's also a new type.  Let's take a look at `cut` again:

```{r eval=FALSE}
diamonds$cut
```

```{r echo=FALSE}
head(diamonds$cut)
```

##

Take a moment to find the different between how this vector is printing in the console to how character vectors print:

```{r}
c("Ideal", "Premium", "Good", "Premium", "Good", "Very Good")
```

What's the difference?

The `cut` variable is a `factor` vector.  A `factor` is similar to a `character` in that they both hold text, but with one BIG difference: `factors` represent categorical variables in a data set with a fixed number of options ("levels" in stats lingo).  The difference between the two can be confusing at first, but you'll come to see that they are an extremely powerful feature as most R functions will understand the distinction between the two and act accordingly.

##

To see the levels of a factor:

```{r}
levels(diamonds$cut)
```

This is a nice quick way to see if you've got a typo in your table in a hand coded column.

## Plotting

As we saw in the last class we can make basic plots with the `plot` function.  Try passing `plot` two quantitative variables:

```{r}
plot(diamonds$carat, diamonds$price)
```

What did you get?

##

Or a quantitative and categorical variable:

```{r}
plot(diamonds$cut, diamonds$price)
```

What did you get there?

The `plot` function is a little bit magical.  It will try very, very hard to draw something no matter what you pass it.  But it doesn't always choose well (if you want to crash your session run `plot(diamonds)`) and you don't even want to know what you have to do to customize the output and make the plots pretty (see `?par`).  It's an awesome function to try out when you're first playing around with a new package or type of data, but you'll quickly be ready to move onto something higher-level.  That's nearly always going to be `ggplot2`.

The `ggplot2` package implements a [semantic visualization](http://vita.had.co.nz/papers/layered-grammar.pdf) framwork.  The idea here is to be systematic about separating and independently describing the fundamental components of a visualization.  If you've ever been frustrated with the inscrutible choices that Excel makes when you try to make a plot, you'll appreciate why this is important.

##

The first component of any plot is **the data**.  You define the table by passing it as the first argument to the `ggplot2` function:

```{r}
ggplot(diamonds)
```

And you get a beautiful empty box.  Exciting!  We'll get there.

The second componet of any plot is **what** you are going to visualize: which variables are you using and what relationship are you interested in?  You do this by passing an "asthetic mapping" as the second value to `ggplot` with the `aes` function.

##

Visualize the `price` variable:

```{r}
ggplot(diamonds, aes(price))
```

##

Visualize the `cut` variable:

```{r}
ggplot(diamonds, aes(cut))
```

##

Visualize `price` as a function of `carat` (independant, dependant):

```{r}
ggplot(diamonds, aes(carat, price))
```

Why does this relationship make more sense than the inverse?

Easy enough, but we're still just getting a grey boxes.  To actually draw something, we need to define the last component of any visualization: **how** the variables should be projected into an image.  In `ggplot` that's the job of the "geom_" functions and well add visualizations to a plot using the `+` operator:

##

A histogram:

```{r}
ggplot(diamonds, aes(price)) + geom_histogram()
```

##

A density distribution:

```{r}
ggplot(diamonds, aes(price)) + geom_density()
```

How do these two methods compare for visualizing the dispersion of values in a quantitative variable?

## Grouping variables

Believe it or not we're really close to creating the plot at the start of the document.  In it, we're visualizing the density distribution of the `depth` variable:

```{r}
ggplot(diamonds, aes(depth)) + geom_density()
```

But in the plot above values for `depth` are grouped by the categorical variable `cut`.  Specifically, the density traces are "filled" with difference colors based on `cut`.

##

To use fill color to group values, we add that to the aesthetic mapping, because it's about **what** we're plotting:

```{r}
ggplot(diamonds, aes(depth, fill = cut)) + geom_density()
```

##

Getting close, but there's a lot of overlap between the traces, so it would be nice to make them a little transparent.  Do that with the `alpha` argument; it's about the **how** the plot is drawn:

```{r}
ggplot(diamonds, aes(depth, fill = cut)) + geom_density(alpha = 0.2)
```

##

Finally, to focus in on the main body of the data (binning out very large and very small values), we can set the x-axis limits with `xlim`:

```{r}
ggplot(diamonds, aes(depth, fill = cut)) + geom_density(alpha = 0.2) + xlim(55, 70)
```

And there it is!

# RMarkdown: reproducible research

> "Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.."
- Donald Knuth, 1983

A few decades ago Donald Knuths proposal that we think of our code as documents for other people to read (which he called [literate programming](https://en.wikipedia.org/wiki/Literate_programming)), has morphed into the development of [reproducible research](https://www.r-bloggers.com/what-is-reproducible-research/) movement in the data sciences which use tools developed for the former to achieve the latter.

##

The key idea here is very simple: if you want to trust your results you should:
- be able to document your manipulation in plain english
- Recreate your **entire** analysis from start to finish from scratch

The latest and greatest tool to facilitate reproducible research workflows in R is [RMarkdown](http://rmarkdown.rstudio.com/) documents.  These documents combine [markdown](https://en.wikipedia.org/wiki/Markdown) text, which is a very simple markup la.nguage with `r` code blocks.  This website is actually just compiled from a [bunch of markdown documents](https://github.com/whitwort/bio185) and all of your assignments will be done using rmarkdown docs. 

Make a new RMarkdown document now with `File -> New File -> R Markdown`.  Take a moment to look at the example formatting.

Clean out the template text and make a new code block that loads `ggplot2` and recreate the plots we've just made with good english documentation of each!

You can preview the results of individual code blocks using the little green "run" button (or ctrl + shift + enter).  But the real test if your results are really reproducible is to "Knit" your document with the Knit button.  This will execute all of your code in a clean, isolated, environment.  If you didn't make any mistakes you'll get a webpage with your code and results.
